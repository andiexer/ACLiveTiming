@page "/"
@using Devlabs.AcTiming.Application.Cars
@using Devlabs.AcTiming.Domain.LiveTiming
@using Devlabs.AcTiming.Web.Hubs
@using Microsoft.AspNetCore.SignalR.Client
@implements IAsyncDisposable
@inject ICarBrandResolver CarBrandResolver

<PageTitle>Live Timing - AC Timing</PageTitle>

<div class="timing-page">

    <!-- ── Session bar ───────────────────────────────────────────────────── -->
    <div class="session-bar">
        <div class="session-bar-left">
            @if (_session is not null)
            {
                <span class="session-type-badge">@_session.SessionType</span>
                <span class="session-track">
                    @_session.TrackName@(string.IsNullOrEmpty(_session.TrackConfig) ? "" : $" · {_session.TrackConfig}")
                </span>
                <span class="session-separator">│</span>
                <span class="session-server">@_session.ServerName</span>
                <span class="session-separator">│</span>
                <span class="session-temps">Road @_session.RoadTemp°C</span>
            }
            else
            {
                <span class="session-waiting">Waiting for session…</span>
            }
        </div>
        <div class="session-bar-right">
            @{
                var timer = FormatSessionTimer();
                if (!string.IsNullOrEmpty(timer))
                {
                    <span class="session-timer">@timer</span>
                }
            }
            <span class="connection-dot @(_hubConnection?.State == HubConnectionState.Connected ? "connected" : "disconnected")">
                ●&nbsp;@(_hubConnection?.State == HubConnectionState.Connected ? "Connected" : "Disconnected")
            </span>
        </div>
    </div>

    <!-- ── Two-column grid ───────────────────────────────────────────────── -->
    @{
        var sorted = _leaderboard
            .OrderBy(d => d.BestLapTimeMs is null or 0 ? 1 : 0)
            .ThenBy(d => d.BestLapTimeMs ?? int.MaxValue)
            .ToList();
        var fastestLap = sorted.FirstOrDefault()?.BestLapTimeMs;
        var overallBest = sorted
            .Where(d => d.BestLapTimeMs is not null and not 0)
            .Min(d => (int?)d.BestLapTimeMs);
        // Fastest sector time across all drivers for each sector (for purple highlight)
        var overallBestSectors = Enumerable.Range(0, 3)
            .Select(s => sorted
                .Where(d => d.BestSectorTimesMs.Count > s && d.BestSectorTimesMs[s] > 0)
                .Select(d => (int?)d.BestSectorTimesMs[s])
                .Min())
            .ToArray();
    }
    <div class="timing-grid">

        <!-- Left column: map + events -->
        <div class="left-col">

            <div class="panel map-panel">
                <div class="panel-header">
                    <span>Map</span>
                    <button class="map-expand-btn" @onclick="() => _mapFullscreen = true" title="Fullscreen map">⤢</button>
                </div>
                <div class="map-body">
                    @if (sorted.Count > 0)
                    {
                        <TrackMap Drivers="sorted" TrackName="@(_session?.TrackName)" TrackConfig="@(_session?.TrackConfig)" SelectedCarId="_selectedCarId" />
                    }
                    else
                    {
                        <span class="panel-empty">No drivers on track</span>
                    }
                </div>
            </div>

            <div class="panel events-panel">
                <div class="panel-header">Events</div>
                <div class="events-list">
                    @if (_events.Count == 0)
                    {
                        <span class="panel-empty">No events yet</span>
                    }
                    @foreach (var evt in _events)
                    {
                        <div class="event-item">
                            <div class="event-indicator event-@evt.Kind.ToString().ToLower()"></div>
                            <div class="event-content">
                                <span class="event-time">@evt.Timestamp.ToLocalTime().ToString("HH:mm:ss")</span>
                                <span class="event-message">@evt.Message</span>
                            </div>
                        </div>
                    }
                </div>
            </div>

        </div>

        <!-- Right column: leaderboard + selected driver -->
        <div class="right-col">

            <div class="panel leaderboard-panel">
                <div class="leaderboard-scroll">
                    @if (sorted.Count == 0)
                    {
                        <span class="panel-empty">No drivers on track</span>
                    }
                    else
                    {
                        <table class="timing-table">
                            <thead>
                                <tr>
                                    <th>Pos</th>
                                    <th>Driver</th>
                                    <th>Car</th>
                                    <th>Best Lap</th>
                                    <th title="Most recent completed lap. Red = invalid (corner cut).">Last Lap</th>
                                    <th class="sector-th" title="Sector 1 time (last lap)">S1</th>
                                    <th class="sector-th" title="Sector 2 time (last lap)">S2</th>
                                    <th class="sector-th" title="Sector 3 time (last lap)">S3</th>
                                    <th title="Delta to personal best">Δ</th>
                                    <th>Laps</th>
                                    <th>
                                        <div class="gap-toggle" title="@(_showInterval ? "Gap to car ahead" : "Gap to leader")">
                                            <button class="gap-toggle-btn @(!_showInterval ? "active" : "")" @onclick="() => _showInterval = false">Gap</button>
                                            <button class="gap-toggle-btn @(_showInterval ? "active" : "")" @onclick="() => _showInterval = true">Int</button>
                                        </div>
                                    </th>
                                </tr>
                            </thead>
                            <tbody>
                                @for (var i = 0; i < sorted.Count; i++)
                                {
                                    var driver = sorted[i];
                                    var prevDriver = i > 0 ? sorted[i - 1] : null;
                                    var isSelected = driver.CarId == _selectedCarId;
                                    <tr class="driver-row @(isSelected ? "selected" : "") @(driver.IsConnected ? "" : "disconnected")"
                                        @onclick="() => SelectDriver(driver.CarId)">
                                        <td class="pos">@(i + 1)</td>
                                        <td class="driver-name">
                                            <span class="driver-pos-bubble" style="background-color: @GetDriverColor(driver.CarId)">@driver.CarId</span>@driver.DriverName
                                        </td>
                                        <td class="car-name">
                                            <CarBrandIcon Model="@driver.CarModel" Resolver="CarBrandResolver" />
                                        </td>
                                        <td class="laptime">@FormatLapTime(driver.BestLapTimeMs)</td>
                                        <td class="laptime @GetLastLapColorClass(driver, overallBest) @(driver.LastLapCuts > 0 ? "lap-invalid" : "")">
                                            @FormatLapTime(driver.LastLapTimeMs)
                                            @if (driver.LastLapCuts > 0)
                                            {
                                                <span class="cuts-badge" title="@driver.LastLapCuts corner cut(s) — lap invalid">@driver.LastLapCuts</span>
                                            }
                                        </td>
                                        <td class="sector-td @GetSectorColorClass(driver, 0, overallBestSectors)">@FormatSectorTime(driver.LastSectorTimesMs, 0)</td>
                                        <td class="sector-td @GetSectorColorClass(driver, 1, overallBestSectors)">@FormatSectorTime(driver.LastSectorTimesMs, 1)</td>
                                        <td class="sector-td @GetSectorColorClass(driver, 2, overallBestSectors)">@FormatSectorTime(driver.LastSectorTimesMs, 2)</td>
                                        <td class="laptime @GetDeltaColorClass(driver)">@FormatDelta(driver)</td>
                                        <td>@driver.TotalLaps</td>
                                        <td class="gap">
                                            @if (_showInterval)
                                            {
                                                @FormatInterval(driver.BestLapTimeMs, prevDriver?.BestLapTimeMs)
                                            }
                                            else
                                            {
                                                @FormatGap(driver.BestLapTimeMs, fastestLap)
                                            }
                                        </td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    }
                </div>
            </div>

            <!-- Selected driver panel — only visible when a row is selected -->
            @if (_selectedCarId is not null)
            {
                var sel = SelectedDriver;
                if (sel is not null)
                {
                    <div class="panel driver-panel">

                        <!-- Driver identity -->
                        @{ var selPos = sorted.FindIndex(d => d.CarId == sel.CarId) + 1; }
                        <div class="driver-panel-header">
                            <div class="dph-pos">
                                <span class="dph-pos-number">@selPos</span>
                                <span class="dph-pos-label">POS</span>
                            </div>
                            <div class="driver-panel-identity">
                                <span class="driver-pos-bubble driver-pos-bubble-lg" style="background-color: @GetDriverColor(sel.CarId)">@sel.CarId</span>
                                <div>
                                    <div class="driver-panel-name">@sel.DriverName</div>
                                    <div class="driver-panel-meta">
                                        <span class="driver-panel-meta-item @(sel.IsConnected ? "status-connected" : "status-disconnected")">
                                            @(sel.IsConnected ? "On track" : "Disconnected")
                                        </span>
                                    </div>
                                </div>
                            </div>
                            <div class="driver-panel-brand-badge">
                                <CarBrandIcon Model="@sel.CarModel" Resolver="CarBrandResolver" ShowLabel Large />
                            </div>
                            <button class="close-btn" @onclick="ClearSelection" title="Close">✕</button>
                        </div>

                        <!-- Live Telemetry -->
                        <div class="dp-section dp-section-telemetry">
                            <div class="dp-section-header">Live Telemetry</div>
                            <div class="dp-telem-row">
                                <div class="dp-telem-cell">
                                    <div class="dp-telem-main">
                                        <span class="dp-telem-value">@(sel.SpeedKmh > 1 ? $"{sel.SpeedKmh:F0}" : "—")</span>
                                        @if (sel.SpeedKmh > 1) { <span class="dp-telem-unit">km/h</span> }
                                    </div>
                                    <div class="dp-telem-label">Speed</div>
                                </div>
                                <div class="dp-telem-cell">
                                    <div class="dp-telem-main">
                                        <span class="dp-telem-value">@FormatGear(sel.Gear)</span>
                                    </div>
                                    <div class="dp-telem-label">Gear</div>
                                </div>
                                <div class="dp-telem-cell dp-telem-rpm">
                                    <div class="rpm-bar">
                                        <div class="rpm-fill" style="width: @(Math.Min(100, sel.EngineRpm / 100.0).ToString("F0"))%"></div>
                                    </div>
                                    <div class="dp-telem-main">
                                        <span class="dp-telem-value">@(sel.EngineRpm > 0 ? sel.EngineRpm.ToString("N0") : "—")</span>
                                    </div>
                                    <div class="dp-telem-label">RPM</div>
                                </div>
                            </div>
                        </div>

                        <!-- Historical -->
                        <div class="dp-section dp-section-history">
                            <div class="dp-section-header">Historical</div>
                            <div class="dp-stat-row">
                                <span class="dp-stat-label">Best this session</span>
                                <span class="dp-stat-value">@FormatLapTime(sel.BestLapTimeMs)</span>
                            </div>
                            <div class="dp-stat-row">
                                <span class="dp-stat-label">Best all-time (car)</span>
                                <span class="dp-stat-value placeholder">—</span>
                            </div>
                            <div class="dp-stat-row">
                                <span class="dp-stat-label">Possible best</span>
                                @{ var possibleBest = PossibleBestLap(sel); }
                                <span class="dp-stat-value @(possibleBest is null ? "placeholder" : "")">@FormatLapTime(possibleBest)</span>
                            </div>
                            <div class="dp-stat-row">
                                <span class="dp-stat-label">Total laps</span>
                                <span class="dp-stat-value">@sel.TotalLaps</span>
                            </div>
                            <div class="dp-stat-row last">
                                <span class="dp-stat-label">Incidents</span>
                                <span class="dp-stat-value">@(_incidents.Count(i => i.CarId == sel.CarId))</span>
                            </div>
                        </div>

                    </div>
                }
            }

        </div>
    </div>

    @if (_mapFullscreen)
    {
        <div class="map-fullscreen-overlay" @onclick="() => _mapFullscreen = false">
            <div class="map-fullscreen-inner" @onclick:stopPropagation>
                <button class="map-fullscreen-close" @onclick="() => _mapFullscreen = false" title="Close">✕</button>
                <TrackMap Drivers="sorted" TrackName="@(_session?.TrackName)" TrackConfig="@(_session?.TrackConfig)" SelectedCarId="_selectedCarId" />
            </div>
        </div>
    }
</div>

@code {
    // ── SignalR & session state ────────────────────────────────────────────
    private HubConnection? _hubConnection;
    private LiveSessionInfo? _session;
    private List<LiveDriverEntry> _leaderboard = [];
    private DateTime? _sessionStartedAt;
    private PeriodicTimer? _tickTimer;
    private CancellationTokenSource? _tickCts;
    private bool _showInterval;

    // ── Map fullscreen ─────────────────────────────────────────────────────
    private bool _mapFullscreen;

    // ── Driver selection ──────────────────────────────────────────────────
    private int? _selectedCarId;
    private LiveDriverEntry? SelectedDriver =>
        _selectedCarId is null ? null : _leaderboard.FirstOrDefault(d => d.CarId == _selectedCarId);

    private void SelectDriver(int carId) =>
        _selectedCarId = _selectedCarId == carId ? null : carId;

    private void ClearSelection() => _selectedCarId = null;

    // ── Events log ────────────────────────────────────────────────────────
    private enum EventKind { SessionStart, SessionEnd, Join, Disconnect, Collision }
    private record TimingEvent(EventKind Kind, MarkupString Message, DateTime Timestamp);
    private readonly List<TimingEvent> _events = [];

    private void AddEvent(EventKind kind, MarkupString message)
    {
        _events.Insert(0, new TimingEvent(kind, message, DateTime.UtcNow));
        if (_events.Count > 10)
            _events.RemoveAt(_events.Count - 1);
    }

    // ── Collision tracking (for incident count in driver panel) ───────────
    private readonly List<CollisionEvent> _incidents = [];

    // ── Initialization ────────────────────────────────────────────────────
    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri(TimingHub.HubUrl))
            .WithAutomaticReconnect()
            .Build();

        _hubConnection.On<LiveSessionInfo?>(TimingHubMethods.SessionUpdated, session =>
        {
            InvokeAsync(() =>
            {
                _session = session;
                if (session is not null)
                {
                    _sessionStartedAt = DateTime.UtcNow - TimeSpan.FromMilliseconds(session.ElapsedMs);
                    AddEvent(EventKind.SessionStart, (MarkupString)$"Session started — {session.TrackName}");
                }
                else
                {
                    _sessionStartedAt = null;
                    AddEvent(EventKind.SessionEnd, (MarkupString)"Session ended");
                }
                StateHasChanged();
            });
        });

        _hubConnection.On<List<LiveDriverEntry>>(TimingHubMethods.LeaderboardUpdated, leaderboard =>
        {
            InvokeAsync(() =>
            {
                _leaderboard = leaderboard;
                StateHasChanged();
            });
        });

        _hubConnection.On<LiveDriverEntry>(TimingHubMethods.DriverUpdated, driver =>
        {
            InvokeAsync(() =>
            {
                var idx = _leaderboard.FindIndex(d => d.CarId == driver.CarId);
                if (idx >= 0)
                    _leaderboard[idx] = driver;
                else
                {
                    _leaderboard.Add(driver);
                    AddEvent(EventKind.Join, (MarkupString)$"{driver.DriverName} joined");
                }
                StateHasChanged();
            });
        });

        _hubConnection.On<int>(TimingHubMethods.DriverDisconnected, carId =>
        {
            InvokeAsync(() =>
            {
                var name = _leaderboard.FirstOrDefault(d => d.CarId == carId)?.DriverName ?? $"Car #{carId}";
                _leaderboard.RemoveAll(d => d.CarId == carId);
                if (_selectedCarId == carId) _selectedCarId = null;
                AddEvent(EventKind.Disconnect, (MarkupString)$"{name} disconnected");
                StateHasChanged();
            });
        });

        _hubConnection.On<CollisionEvent>(TimingHubMethods.CollisionOccurred, evt =>
        {
            InvokeAsync(() =>
            {
                _incidents.Insert(0, evt);
                if (_incidents.Count > 50)
                    _incidents.RemoveAt(_incidents.Count - 1);
                AddEvent(EventKind.Collision, FormatIncidentMarkup(evt));
                StateHasChanged();
            });
        });

        await _hubConnection.StartAsync();
        await _hubConnection.InvokeAsync("RequestFullState");

        StartTickTimer();
    }

    private void StartTickTimer()
    {
        _tickCts = new CancellationTokenSource();
        _tickTimer = new PeriodicTimer(TimeSpan.FromSeconds(1));
        _ = TickLoopAsync(_tickCts.Token);
    }

    private async Task TickLoopAsync(CancellationToken ct)
    {
        while (await _tickTimer!.WaitForNextTickAsync(ct))
        {
            if (_session is not null && _sessionStartedAt is not null)
                await InvokeAsync(StateHasChanged);
        }
    }

    [Inject] private NavigationManager NavigationManager { get; set; } = default!;

    // ── Formatting helpers ─────────────────────────────────────────────────
    private MarkupString FormatIncidentMarkup(CollisionEvent evt)
    {
        var dot1 = DriverDotHtml(evt.CarId);
        var name1 = GetDriverName(evt.CarId);

        if (evt.Type == CollisionType.Car && evt.OtherCarId.HasValue)
        {
            var dot2 = DriverDotHtml(evt.OtherCarId.Value);
            var name2 = GetDriverName(evt.OtherCarId.Value);
            return (MarkupString)$"{dot1}{name1} ↔ {dot2}{name2} — {evt.ImpactSpeedKmh:F0} km/h";
        }

        return (MarkupString)$"{dot1}{name1} environment crash — {evt.ImpactSpeedKmh:F0} km/h";
    }

    private string DriverDotHtml(int carId) =>
        $"<span class=\"driver-dot\" style=\"background-color:{GetDriverColor(carId)}\"></span>";

    private string GetDriverName(int carId) =>
        _leaderboard.FirstOrDefault(d => d.CarId == carId)?.DriverName ?? $"Car #{carId}";

    private static readonly string[] DriverColors =
    [
        "#e94560", "#4ecca3", "#3498db", "#f39c12",
        "#9b59b6", "#1abc9c", "#e67e22", "#2ecc71",
        "#e74c3c", "#00cec9", "#fd79a8", "#6c5ce7"
    ];

    private static string GetDriverColor(int carId) => DriverColors[carId % DriverColors.Length];

    private static string FormatLapTime(int? ms)
    {
        if (ms is null or 0) return "—";
        var ts = TimeSpan.FromMilliseconds(ms.Value);
        return ts.Minutes > 0
            ? $"{ts.Minutes}:{ts.Seconds:D2}.{ts.Milliseconds:D3}"
            : $"{ts.Seconds}.{ts.Milliseconds:D3}";
    }

    private static string FormatGap(int? driverMs, int? leaderMs)
    {
        if (driverMs is null or 0 || leaderMs is null or 0) return "—";
        var gap = driverMs.Value - leaderMs.Value;
        if (gap == 0) return FormatLapTime(driverMs);
        return FormatSignedGap(gap);
    }

    private static string FormatInterval(int? driverMs, int? aheadMs)
    {
        if (aheadMs is null) return FormatLapTime(driverMs);
        if (driverMs is null or 0 || aheadMs is 0) return "—";
        var gap = driverMs.Value - aheadMs.Value;
        if (gap == 0) return FormatLapTime(driverMs);
        return FormatSignedGap(gap);
    }

    private static string FormatDelta(LiveDriverEntry driver)
    {
        if (driver.LastLapTimeMs is null or 0 || driver.BestLapTimeMs is null or 0) return "—";
        var delta = driver.LastLapTimeMs.Value - driver.BestLapTimeMs.Value;
        if (delta == 0) return "PB";
        return FormatSignedGap(delta);
    }

    private static string FormatSignedGap(int ms)
    {
        var sign = ms >= 0 ? "+" : "-";
        var abs = Math.Abs(ms) / 1000.0;
        return $"{sign}{abs:F3}";
    }

    private static string FormatGear(int gear) => gear switch
    {
        0 => "R",
        1 => "N",
        _ => (gear - 1).ToString()
    };

    private static string GetLastLapColorClass(LiveDriverEntry driver, int? overallBest)
    {
        if (driver.LastLapTimeMs is null or 0) return "";
        if (driver.LastLapCuts > 0) return "";
        if (overallBest is not null && driver.LastLapTimeMs == overallBest) return "lap-purple";
        if (driver.BestLapTimeMs is not null && driver.LastLapTimeMs == driver.BestLapTimeMs) return "lap-green";
        return "lap-yellow";
    }

    private static string FormatSectorTime(List<int> sectors, int index)
    {
        if (sectors.Count <= index || sectors[index] <= 0) return "—";
        var ts = TimeSpan.FromMilliseconds(sectors[index]);
        return ts.Minutes > 0
            ? $"{ts.Minutes}:{ts.Seconds:D2}.{ts.Milliseconds:D3}"
            : $"{ts.Seconds}.{ts.Milliseconds:D3}";
    }

    private static string GetSectorColorClass(LiveDriverEntry driver, int index, int?[] overallBestSectors)
    {
        if (driver.LastSectorTimesMs.Count <= index || driver.LastSectorTimesMs[index] <= 0) return "";
        var sectorTime = driver.LastSectorTimesMs[index];
        if (overallBestSectors.Length > index && overallBestSectors[index] is not null && sectorTime <= overallBestSectors[index])
            return "lap-purple";
        if (driver.BestSectorTimesMs.Count > index && sectorTime <= driver.BestSectorTimesMs[index])
            return "lap-green";
        return "lap-yellow";
    }

    private static int? PossibleBestLap(LiveDriverEntry driver)
    {
        if (driver.BestSectorTimesMs.Count < 3 || driver.BestSectorTimesMs.Any(s => s <= 0)) return null;
        return driver.BestSectorTimesMs[0] + driver.BestSectorTimesMs[1] + driver.BestSectorTimesMs[2];
    }

    private static string GetDeltaColorClass(LiveDriverEntry driver)
    {
        if (driver.LastLapTimeMs is null or 0 || driver.BestLapTimeMs is null or 0) return "";
        var delta = driver.LastLapTimeMs.Value - driver.BestLapTimeMs.Value;
        return delta == 0 ? "delta-pb" : "delta-positive";
    }

    private string FormatSessionTimer()
    {
        if (_session is null || _sessionStartedAt is null) return "";

        if (_session.TimeLimitMinutes > 0)
        {
            var totalSeconds = _session.TimeLimitMinutes * 60;
            var elapsed = (DateTime.UtcNow - _sessionStartedAt.Value).TotalSeconds;
            var remaining = Math.Max(0, totalSeconds - elapsed);
            var ts = TimeSpan.FromSeconds(remaining);
            return $"{(int)ts.TotalMinutes}:{ts.Seconds:D2}";
        }

        if (_session.LapLimit > 0)
        {
            var maxLaps = _leaderboard.Count > 0 ? _leaderboard.Max(d => d.TotalLaps) : 0;
            return $"Lap {maxLaps} / {_session.LapLimit}";
        }

        return "";
    }

    public async ValueTask DisposeAsync()
    {
        _tickCts?.Cancel();
        _tickTimer?.Dispose();
        _tickCts?.Dispose();
        if (_hubConnection is not null)
            await _hubConnection.DisposeAsync();
    }
}
